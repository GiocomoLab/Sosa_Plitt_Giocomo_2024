import pandas as pd
import numpy as np
import scipy as sp
import math
from matplotlib import pyplot as plt
from matplotlib import gridspec
from matplotlib import axes as axes

import TwoPUtils

from . import behavior
from . import plotUtils as pt
from . import utilities as ut
from . import spatial
from . import circ


def single_cell_mat(cell_idx, dff_, sigma=2, normalization_method=None, sort_by=None):
    """
    create normalized spatial activity trial matrix for a single cell

    :param cell_idx: single index along axis=2 of dff_
    :param dff_: expected to be array of shape (trials x spatial bins x ROIs)
    :param sigma: smoothing gaussian s.d. (bins)
    :param normalization_method: how to normalize activity for plotting
            options: 'mean', 'max', 'zscore'
    :param sort_by: how to sort the trials
            -- if None, trials are sorted chronologically (i.e. no sorting)
            -- suggested options are: isreward,morph,dream, from behav.get_trial_types
            -- these should be vectors of 1s and 0s, not a string name
    :return: c - activity trial matrix to plot;
            c_vlim - [minimum,maximum] activity level to plot based on normalization method
    """

    dff = np.copy(dff_)

    if sort_by is not None:
        sort = np.argsort(sort_by, kind='stable')
        dff = np.squeeze(dff[sort, :, :])

    c = dff[:, :, cell_idx]
    c[np.isnan(c)] = 0

    if normalization_method == 'mean':
        # normalize by mean
        c /= np.nanmean(c.ravel())
        c_vlim = [0, 10]

    elif normalization_method == 'max':
        # normalize by max
        c /= np.nanmax(c.ravel())
        c_vlim = [0.2, 0.8]

    elif normalization_method == 'zscore':
        c = (c - np.nanmean(c.ravel()))/np.nanstd(c.ravel())
        c_vlim = [-2, 4]

    elif normalization_method == 'max_trial_avg':
        # normalize to the max of the trial-averaged activity within session
        max_trial_avg = np.nanmax(np.nanmean(c, axis=0, keepdims=True), axis=1)
        c /= max_trial_avg
        c_vlim = [0, 1]

    # do some smoothing in position axis for visualization
    if sigma is not None and (sigma != 0):
        c = ut.nansmooth(c, sigma, axis=1)

    return c, c_vlim


def plot_single_cell(ax,
                     cell_idx=None,
                     trial_mat=None,
                     vlim=[0, 1],
                     sigma=2,
                     normalization_method='max',
                     reward_zone=None,
                     div_reward_zone=True,
                     markersize=1,
                     sort_by=None,
                     plot_colorbar=False,
                     label_axes=True,
                     cmap='magma',
                     **kwargs
                     ):
    """
    Plot single cell spatially-binned activity ratemap

    :param ax: figure axis activity plot (must be given)
    :param cell_idx: if specified, we will calculate the matrix to plot from mat
    :param trial_mat: dff array of shape trials x spatial bins x ROIs
            -- if cell_idx is not none, mat should be the full sess.trial_matrics['dff']
            and cell_idx will index into ROIs along axis=2
            -- if cell_idx is none, mat should be a single pre-smoothed matrix to
            plot (which can be generated by single_cell_mat)
    :param vlim: color scale limits to plot
    :param sigma: smoothing guassian s.d. (bins)
    :param normalization_method: how to normalize activity for plotting
            -- options: 'mean', 'max', 'zscore', 'max_trial_avg'
            -- gets passed to single_cell_mat
    :param reward_zone: 2D array of ntrials x reward_zone [start,stop]
            -- if this exists, dots will be plotted at the reward zone start
    :param markersize: dot size for marking reward zone start
    :param sort_by: how to sort the trials
            -- if None, trials are sorted chronologically (i.e. no sorting)
            -- suggested options are: isreward,morph,dream, from get_trial_types
            -- these should be vectors of 1s and 0s, not a string name
    :param plot_colorbar: whether to plot a horizontal colorbar below each cell
            -- default = False because it squishes the axes
    :param label_axes: whether to plot axes and tick mark labels
    :param cmap: color map
    :param kwargs:
    :return: plots the figure
    """

    trial_mat = np.copy(trial_mat)
    if cell_idx is None and trial_mat is None:
        raise NotImplementedError(
            "You must give a cell index, a trial matrix, or both")

    # trial matrix
    if cell_idx is not None:
        trial_mat, vlim = single_cell_mat(cell_idx,
                                          trial_mat,
                                          sigma=sigma,
                                          normalization_method=normalization_method)

    if sort_by is not None:
        sort = np.argsort(sort_by, kind='stable')
        trial_mat = trial_mat[sort, :]
        if reward_zone is not None:
            reward_zone = reward_zone[sort, :]

    mat_plot = ax.imshow(trial_mat, cmap=cmap,
                         aspect='auto', vmin=vlim[0], vmax=vlim[1],
                         **kwargs)

    if label_axes:
        ax.set_ylabel('Trial #')
        ax.set_xlabel('position (10 cm bin)')
    else:
        ax.set_yticks([])
        ax.set_xticks([])

    if cell_idx is not None:
        ax.set_title(("%d" % cell_idx))
    axes.Axes.set_ylim(ax, bottom=trial_mat.shape[0])
    if plot_colorbar:
        fig = plt.gcf()
        fig.colorbar(mat_plot, ax=ax, orientation='horizontal')
    if reward_zone is not None:
        if reward_zone[0, 0] > 10:
            ax.plot(reward_zone[:, 0]/10, np.arange(trial_mat.shape[0]),
                    'w.', markersize=markersize)
        else:
            ax.plot(reward_zone[:, 0], np.arange(trial_mat.shape[0]),
                    'w.', markersize=markersize)
    return


def plot_single_cell_dual(sess,
                          cell_idx,
                          c_ax,
                          d_ax,
                          sigma=2,
                          normalization_method=None,
                          reward_zone=None,
                          markersize=1,
                          sort_by=None,
                          plot_colorbar=False,
                          **kwargs
                          ):
    """
    Plot single cell spatially-binned activity ratemap, dual channel

    :param sess: session class, requires sess.trial_matrices['dff'] and ['dff2']
    :param cell_idx: single index along axis=2 of dff
    :param c_ax: figure axis for calcium activity plot (ch1)
    :param d_ax: figure axis for channel 2 plot
    :param sigma: smoothing guassian s.d. (bins)
    :param normalization_method: how to normalize activity for plotting
            -- options: 'mean', 'max', 'zscore'
            -- gets passed to single_cell_mat
    :param reward_zone: 2D array of ntrials x reward_zone [start,stop]
    :param markersize: marker size for reward zone plotting
    :param sort_by: how to sort the trials
            -- if None, trials are sorted chronologically (i.e. no sorting)
            -- suggested options are: isreward,morph,dream, from get_trial_types
            -- these should be vectors of 1s and 0s, not a string name
    :param plot_colorbar: whether to plot a horizontal colorbar below each cell
            -- default = False because it squishes the axes
    :param kwargs: standard matplotlib keyword args
    :return:
    """

    # trial matrics of place cells for ch1 (dff) and ch2 (dff2)
    dff = np.copy(sess.trial_matrices['dff'][0])
    dff2 = np.copy(sess.trial_matrices['dff2'][0])

    if sort_by is not None:
        sort = np.argsort(sort_by, kind='stable')
        dff = dff[sort, :, :]
        dff2 = dff2[sort, :, :]
        if reward_zone is not None:
            reward_zone = reward_zone[sort, :]

    c, c_vlim = single_cell_mat(
        cell_idx, dff, sigma=sigma, normalization_method=normalization_method)
    d, d_vlim = single_cell_mat(
        cell_idx, dff2, sigma=sigma, normalization_method=normalization_method)

    c_plot = c_ax.imshow(c, cmap='magma', aspect='auto',
                         vmin=c_vlim[0], vmax=c_vlim[1])
    c_ax.set_ylabel('Trial #')
    c_ax.set_xlabel('position (10 cm bin)')
    c_ax.set_title("%d" % cell_idx + ' ch1')
    axes.Axes.set_ylim(c_ax, bottom=c.shape[0])
    if plot_colorbar:
        fig = plt.gcf()
        fig.colorbar(c_plot, ax=c_ax, orientation='horizontal')

    d_plot = d_ax.imshow(d, cmap='viridis', aspect='auto',
                         vmin=d_vlim[0], vmax=d_vlim[1])
    d_ax.set_xlabel('position (10 cm bin)')
    d_ax.set_title("%d" % cell_idx + ' ch2')
    axes.Axes.set_ylim(d_ax, bottom=d.shape[0])
    if plot_colorbar:
        fig.colorbar(d_plot, ax=d_ax, orientation='horizontal')

    if reward_zone is not None:
        c_ax.plot(reward_zone[:, 0]/10, np.arange(c.shape[0]),
                  'w.', markersize=markersize)
        d_ax.plot(reward_zone[:, 0]/10, np.arange(c.shape[0]),
                  'w.', markersize=markersize)

    return


def plot_all_single_cells_dual(sess,
                               pc_masks,
                               sigma=2,
                               normalization_method='mean',
                               plot_reward_zone=False):
    """
    Dual channel plotting of all cells where pc_masks==True
    Assumes dff is calcium activity and dff2 is another sensor/indicator

    :param sess: session class, requires sess.trial_matrices['dff'] and ['dff2']
    :param pc_masks: boolean mask of which ROIs are place cells
    :param sigma: guassian s.d. for smoothing (in bins)
    :param normalization_method: how to normalize activity for plotting
            -- options: 'mean', 'max', 'zscore'
            -- gets passed to _single_cell_mat
    :param plot_reward_zone: whether to plot dots marking start of reward zone
    :return: plots the figure
    """

    # set up axes
    xstride = 3
    ystride = 4
    nperrow = 8
    fig = plt.figure(figsize=[nperrow*xstride, pc_masks.sum()/nperrow*ystride])
    # gridspec is fancy subplot controller, can specify how big each one is exactly
    # set defined resolution for plot grid
    gs = gridspec.GridSpec(
        math.ceil(pc_masks.sum()/nperrow)*ystride, xstride*nperrow)
    # trial matrics of place cells for ch1 (_tm) and ch2 (_dff2_tm)
    _tm = sess.trial_matrices['dff'][0][:, :, pc_masks]
    _dff2_tm = sess.trial_matrices['dff2'][0][:, :, pc_masks]

    # original index of ROIs that are place cells
    cellID = np.where(pc_masks)[0]

    if plot_reward_zone:
        reward_zone, _ = behavior.get_reward_zones(sess)

    for cell in range(_tm.shape[-1]):

        c, c_vlim = single_cell_mat(cell, _tm, sigma=sigma,
                                    normalization_method=normalization_method)
        d, d_vlim = single_cell_mat(cell, _dff2_tm, sigma=sigma,
                                    normalization_method=normalization_method)

        # add plots
        row_i = int(ystride*math.floor(cell/nperrow))
        col_i = int(xstride*(cell % nperrow))

        # specifiy which grid to plot cells
        c_ax = fig.add_subplot(gs[row_i:row_i+ystride-1, col_i])
        c_ax.imshow(c, cmap='magma', aspect='auto',
                    vmin=c_vlim[0], vmax=c_vlim[1])

        d_ax = fig.add_subplot(gs[row_i:row_i+ystride-1, col_i+1])
        d_ax.imshow(d, cmap='viridis', aspect='auto',
                    vmin=d_vlim[0], vmax=d_vlim[1])

        if plot_reward_zone:
            c_ax.plot(reward_zone[:, 0]/10,
                      np.arange(c.shape[0]), 'w.', markersize=1)
            d_ax.plot(reward_zone[:, 0]/10,
                      np.arange(c.shape[0]), 'w.', markersize=1)

        c_ax.set_yticks([])
        d_ax.set_xticks([])
        c_ax.set_xticks([])
        d_ax.set_yticks([])
        d_ax.set_title("%d" % cellID[cell])

        if row_i == 0 and col_i == 0:
            c_ax.set_ylabel('Trial #')

    fig.patch.set_facecolor('white')

    return fig


def plot_all_single_cells(sess,
                          pc_masks=None,
                          ts_key='dff',
                          sigma=2,
                          normalization_method='mean',
                          speed_thr=2,
                          use_speed_thr=False,
                          max_cells=None,
                          plot_reward_zone=False,
                          plot_teleports=False,
                          metrics=None,
                          label_by_keys=None,
                          sort_by_key=None,
                          trial_subset=None,
                          field_pos=None,
                          circ_shift=False,
                          plot_peaks=False,
                          impute_nans=False,
                          **kwargs):
    """
    Single channel plotting of all cells where pc_masks==True

    :param sess: session class, requires sess.trial_matrices['dff'] and ['dff2']
    :param pc_masks: boolean mask of which ROIs are place cells
    :param sigma: guassian s.d. for smoothing (in bins)
    :param normalization_method: how to normalize activity for plotting
            -- options: 'mean', 'max', 'zscore'
            -- gets passed to _single_cell_mat
    :param plot_reward_zone: whether to plot dots marking start of reward zone
    :return: plots the figure
    """

    # set up axes
    xstride = 3
    ystride = 4
    nperrow = 8

    if pc_masks is None:
        pc_masks = np.ones(
            (sess.trial_matrices[ts_key][0].shape[2],), dtype=bool)

    if type(pc_masks) is not bool:
        tmp_masks = np.zeros(
            (sess.trial_matrices[ts_key][0].shape[2],), dtype=bool)
        tmp_masks[pc_masks] = True
        pc_masks = np.copy(tmp_masks)

    if max_cells is None:
        max_cells = pc_masks.sum()
    else:
        max_cells = np.min([max_cells, pc_masks.sum()])

    if 'cmap' not in kwargs.keys():
        cmap = 'magma'
    else:
        cmap = kwargs['cmap']

    if max_cells == 0:
        raise NotImplementedError("No cells to plot")

    # fig = plt.figure(figsize=[nperrow*xstride, max_cells/nperrow*ystride])
    # gridspec is fancy subplot controller, can specify how big each one is exactly
    # set defined resolution for plot grid

    # Define the number of subplots
    nrows = math.ceil(max_cells/nperrow)*ystride
    ncols = nperrow*xstride

    # Define the size of each subplot in inches
    subplot_width = 1
    subplot_height = 1.3

    # Define the spacing between subplots in inches
    wspace = 0.5
    hspace = 0.75

    # Calculate the overall figure size
    fig_width = ncols * subplot_width + (ncols - 1) * wspace
    fig_height = nrows * subplot_height + (nrows - 1) * hspace

    # Create a figure with the calculated size
    fig = plt.figure(figsize=(fig_width, fig_height))

    # Create a GridSpec with the specified layout
    gs = gridspec.GridSpec(nrows, ncols,
                           width_ratios=[subplot_width]*ncols,
                           height_ratios=[subplot_height]*nrows,
                           wspace=wspace/fig_width, hspace=hspace/fig_height)

    # gs = gridspec.GridSpec(math.ceil(max_cells/nperrow)*ystride, xstride*nperrow)

    if plot_reward_zone:
        reward_zone, _ = behavior.get_reward_zones(sess)

    # original index of ROIs that are place cells
    cellID = np.where(pc_masks)[0]
    cellID_notpc = np.where(~pc_masks)[0]

    if label_by_keys is not None:
        use_metrics = dict.copy(metrics)

    max_pos = sess.trial_matrices[ts_key][-2][-1]  # 450
    if plot_teleports:
        min_pos = -50
    else:
        min_pos = sess.trial_matrices[ts_key][-2][0]

    lin_bin_size = np.mean(
        np.diff(sess.trial_matrices[ts_key][-2]))

    trial_dict = behavior.define_trial_subsets(sess, force_two_sets=True)

    if plot_teleports:
        tstart_inds = sess.teleport_inds[:-1]
        tstop_inds = sess.teleport_inds[1:] - 1
        trial_set0 = trial_dict['trial_set0'][1:]
        trial_set1 = trial_dict['trial_set1'][1:]
        reward_zone = reward_zone[1:, :]
    else:
        tstart_inds = sess.trial_start_inds
        tstop_inds = sess.teleport_inds
        trial_set0 = trial_dict['trial_set0']
        trial_set1 = trial_dict['trial_set1']

    if circ_shift:
        from . import circ

        circ_bin_size = 2*np.pi/((max_pos-min_pos)/lin_bin_size)

        pos = sess.trial_matrices[ts_key][-1]

        circ_pos = spatial.pos_cm_to_rad(
            sess.vr_data['pos'].values, max_pos, min_pos=min_pos)
        rzone0 = np.unique(reward_zone[trial_set0, :])
        rzone1 = np.unique(reward_zone[trial_set1, :])

        rzone_diff = rzone0[0] - rzone1[0]

        circ_rzone0 = spatial.pos_cm_to_rad(rzone0, max_pos, min_pos=min_pos)
        circ_rzone1 = spatial.pos_cm_to_rad(rzone1, max_pos, min_pos=min_pos)

        circ_tm = TwoPUtils.spatial_analyses.trial_matrix(sess.timeseries[ts_key].T,
                                                          circ_pos,
                                                          tstart_inds,
                                                          tstop_inds,
                                                          bin_size=circ_bin_size,
                                                          min_pos=-np.pi,
                                                          max_pos=np.pi,
                                                          speed_thr=2,
                                                          speed=sess.vr_data['speed'].values
                                                          )
        # find the number of indices that aligns rzone1 with rzone 1
        if rzone0[0] > rzone1[0]:
            shift = int(
                np.round((circ_rzone0[0]-circ_rzone1[0])/circ_bin_size))
            trackstart_shift = circ.phase_diff(spatial.pos_cm_to_rad(np.abs(rzone_diff), max_pos, min_pos=min_pos),
                                               spatial.pos_cm_to_rad(0, max_pos, min_pos=min_pos))

        elif rzone1[0] > rzone0[0]:
            shift = - \
                int(np.round((circ_rzone1[0]-circ_rzone0[0])/circ_bin_size))
            trackstart_shift = -circ.phase_diff(spatial.pos_cm_to_rad(np.abs(rzone_diff), max_pos, min_pos=min_pos),
                                                spatial.pos_cm_to_rad(0, max_pos, min_pos=min_pos))

        print(shift)

        circ_tm[0][trial_set1, :, :] = np.roll(
            circ_tm[0][trial_set1, :, :],
            shift,
            axis=1
        )

        circ_rzone1 = circ.wrap(
            circ_rzone1 + circ.wrap(circ_rzone0[0]-circ_rzone1[0])
        )

        reward_zone = np.vstack((
            np.tile(np.expand_dims(circ_rzone0, 1).T,
                    (len(np.where(trial_set0)[0]), 1)),
            np.tile(np.expand_dims(circ_rzone1, 1).T,
                    (len(np.where(trial_set1)[0]), 1))
        ))
        if plot_teleports:
            trackstarts = np.zeros((reward_zone.shape[0],))
            teleports = np.zeros((reward_zone.shape[0],))
            # trackstart_shift = circ.phase_diff(spatial.pos_cm_to_rad(np.abs(rzone_diff), max_pos, min_pos=min_pos),
            #                                  spatial.pos_cm_to_rad(0, max_pos, min_pos=min_pos))
            # print(trackstart_shift)
            trackstarts[trial_set0] = spatial.pos_cm_to_rad(
                0, max_pos, min_pos=min_pos)
            trackstarts[trial_set1] = circ.wrap(
                trackstarts[trial_set0][0] + trackstart_shift)
            teleports[trial_set0] = spatial.pos_cm_to_rad(
                max_pos, max_pos, min_pos=min_pos)
            teleports[trial_set1] = circ.wrap(
                teleports[trial_set0][0] + trackstart_shift)

        tm = circ_tm
        use_tm = tm[0][:, :, pc_masks]
    else:
        # recompute trial matrix using speed threshold if specified
        if use_speed_thr:
            speed = np.copy(sess.timeseries['speed'][0])
            tm = TwoPUtils.spatial_analyses.trial_matrix(sess.timeseries[ts_key].T,
                                                         sess.vr_data['pos']._values,
                                                         tstart_inds,
                                                         tstop_inds,
                                                         bin_size=10,
                                                         min_pos=min_pos,
                                                         max_pos=max_pos,
                                                         speed_thr=speed_thr,
                                                         speed=speed
                                                         )
        else:
            speed = None
            tm = np.copy(sess.trial_matrices[ts_key])

        if plot_teleports:
            reward_zone = reward_zone[1:]
            trackstarts = np.zeros((reward_zone.shape[0],))
            teleports = np.ones((reward_zone.shape[0],))*max_pos

        # tm = TwoPUtils.spatial_analyses.trial_matrix(sess.timeseries[ts_key].T,
        #                                           sess.vr_data['pos']._values,
        #                                           tstart_inds,
        #                                           tstop_inds,
        #                                           bin_size=10,
        #                                           min_pos=min_pos,
        #                                           max_pos=max_pos,
        #                                           speed_thr=speed_thr,
        #                                           speed=speed
        #                                           )

    if impute_nans:
        for trial in range(tm[0].shape[0]):
            nan_inds = np.isnan(tm[0][trial, :, 0])
            _c = tm[-1][~nan_inds]
            for cell in range(tm[0].shape[2]):
                _m = tm[0][trial, ~nan_inds, cell]
                tm[0][trial, :, cell] = np.interp(tm[-1], _c, _m)

    if sort_by_key is not None and metrics is not None:
        sort = np.argsort(metrics[sort_by_key], kind='stable')
        dummy_cellID = np.copy(pc_masks).astype(int)
        # means it's not a place cell
        dummy_cellID[dummy_cellID == 0] = cellID_notpc
        dummy_cellID[cellID] = cellID

        use_tm = tm[0][:, :, np.flip(sort)]
        pc_masks = pc_masks[np.flip(sort)]

        cellID = np.copy(dummy_cellID)[np.flip(sort)]

        use_tm = tm[0][:, :, pc_masks]

    else:
        # original index of ROIs that are place cells
        use_tm = tm[0][:, :, pc_masks]

    if trial_subset is not None:
        use_tm = use_tm[trial_subset, :, :]
        reward_zone = reward_zone[trial_subset, :]

    if plot_peaks:
        peaks = {'set 0': [],
                 'set 1': []
                 }
        peaks['set 0'] = spatial.peak(
            np.nanmean(
                use_tm[trial_set0, :],
                axis=0),
            tm[-1],
            axis=0
        )
        peaks['set 1'] = spatial.peak(
            np.nanmean(
                use_tm[trial_set1, :],
                axis=0),
            tm[-1],
            axis=0
        )
    # Iterate and plot cells
    for cell in range(max_cells):

        c, c_vlim = single_cell_mat(cell, use_tm, sigma=sigma,
                                    normalization_method=normalization_method)

        # add plots
        row_i = int(ystride*math.floor(cell/nperrow))
        col_i = int(xstride*(cell % nperrow))
        # row_i = int(math.floor(cell/nperrow))
        # col_i = int((cell % nperrow))

        # specifiy which grid to plot cells
        c_ax = fig.add_subplot(
            gs[row_i:row_i+ystride-1, col_i:col_i+xstride-1])
        # c_ax = fig.add_subplot(
        # gs[row_i, col_i])
        c_ax.imshow(c, cmap=cmap, extent=(tm[-2][0], tm[-2][-1], use_tm.shape[0], 0),
                    aspect='auto',
                    vmin=c_vlim[0], vmax=c_vlim[1])

        if plot_reward_zone:
            c_ax.plot(reward_zone[:, 0],
                      np.arange(c.shape[0]), 'w.', markersize=1)

        if plot_teleports:
            c_ax.plot(trackstarts,
                      np.arange(c.shape[0]), '.', color=(0, 1, 0, 1), markersize=1)
            c_ax.plot(teleports,
                      np.arange(c.shape[0]), '.', color=(0.45, 0.45, 0.45, 1), markersize=1)

        if plot_peaks:
            c_ax.vlines(peaks['set 0'][cell], np.where(trial_dict['trial_set0'])[0][0],
                        np.where(trial_dict['trial_set0'])[0][-1], color='c', linewidth=0.75)
            c_ax.vlines(peaks['set 1'][cell], np.where(trial_dict['trial_set1'])[0][0],
                        np.where(trial_dict['trial_set1'])[0][-1], color='c', linewidth=0.75)
            if circ_shift:
                peak_diff = circ.phase_diff(
                    peaks['set 0'][cell], peaks['set 1'][cell])
            else:
                peak_diff = peaks['set 0'][cell] - peaks['set 1'][cell]

        if field_pos is not None:
            if type(field_pos) == dict:
                # assuming the dict is by trial set
                if ('set 0' in field_pos.keys()) and ('set 1' in field_pos.keys()):

                    for f in field_pos['set 0']['pos'][cellID[cell]]:
                        if circ_shift:
                            f = spatial.pos_cm_to_rad(
                                f, max_pos, min_pos=min_pos)

                        c_ax.plot(f,
                                  np.zeros((len(f),))-4,
                                  'g', linewidth=1.5)
                    for f in field_pos['set 1']['pos'][cellID[cell]]:
                        if circ_shift:
                            f = circ.wrap(spatial.pos_cm_to_rad(
                                f, max_pos, min_pos) + circ.wrap(spatial.pos_cm_to_rad(
                                rzone0[0], max_pos, min_pos=min_pos
                                
                            ) - spatial.pos_cm_to_rad(rzone1[0], max_pos, min_pos=min_pos
                                                                                                                 
                                                     )))

                        c_ax.plot(f,
                                  np.zeros((len(f),))-2,
                                  'r', linewidth=1.5)

                    # c_ax.set_ylim([-2.5, use_tm.shape[0]])
                else:
                    raise NotImplementedError(
                        'field pos dictionary does not appear to be organized by trial set')

            # else:
            #     [c_ax.plot(f,
            #                np.zeros((len(f),))
            #               , 'g.', markersize=5) for f in field_pos[cellID[cell]]]

        # c_ax.set_yticks([])
        # c_ax.set_xticks([])
        if label_by_keys is not None:
            c_ax.set_title("%d, %s" % (int(cellID[cell]),
                                       [f'{use_metrics[key][cellID[cell]]:.2f}' for key in label_by_keys]))
        else:
            if plot_peaks:
                c_ax.set_title("%d, %f" % (cellID[cell], peak_diff))
            else:
                c_ax.set_title("%d" % (cellID[cell]))

        if row_i == 0 and col_i == 0:
            c_ax.set_ylabel('Trial #')

    fig.patch.set_facecolor('white')

    return fig


def plot_single_cells_w_similarity_matrix(an,
                                          cell_mask,
                                          multi_anim_sess_in,
                                          ts_key='events',
                                          sigma=1,
                                          circ_shift=False,
                                          use_speed_thr=True,
                                          sim_method='correlation',
                                          max_pos=450,
                                          min_pos=0,
                                          lin_bin_size=10):
    """
    This function is similar to placeCellPlot.plot_all_single_cells
    but adds the trial-by-trial correlation matrix next to each cell

    Title of each plot will report the lag of the peak xcorr of the trial-averaged
    firing in trial set 0 vs 1 in the current axes (not relative to shuffle), 
    so if circ_shift==False, this will be the linear track coordinates, 
    and if circ_shift==True, this will be circular coordinates relative to reward.
    """
    from . import xcorr as xc

    # option to plot a specific category defined in cell classes
    category = 'disappear'  # if None, will plot all place cells as defined below

    if use_speed_thr:
        speed = np.copy(multi_anim_sess_in[an]
                        ['sess'].vr_data['speed'].values)
    else:
        speed = None

    figtag = ''
    if circ_shift:
        figtag = figtag + 'circShift'
    if use_speed_thr:
        figtag = figtag + '_useSpeed'

    if circ_shift:
        circ_bin_size = 2*np.pi/((max_pos-min_pos)/lin_bin_size)

        # teleport starts at -50, so add 50 to make it start at 0 and track end at 500
        circ_pos = spatial.pos_cm_to_rad(
            multi_anim_sess_in[an]['sess'].vr_data['pos'].values, max_pos, min_pos)
        rzone0 = np.unique(multi_anim_sess_in[an]['rzone'][
            multi_anim_sess_in[an]['trial dict']['trial_set0'], :])
        rzone1 = np.unique(multi_anim_sess_in[an]['rzone'][
            multi_anim_sess_in[an]['trial dict']['trial_set1'], :])

        circ_rzone0 = spatial.pos_cm_to_rad(rzone0, max_pos, min_pos)
        circ_rzone1 = spatial.pos_cm_to_rad(rzone1, max_pos, min_pos)

        tm = TwoPUtils.spatial_analyses.trial_matrix(multi_anim_sess_in[an]['sess'].timeseries[ts_key].T,
                                                     circ_pos,
                                                     multi_anim_sess_in[an]['sess'].trial_start_inds,
                                                     multi_anim_sess_in[an]['sess'].teleport_inds,
                                                     bin_size=circ_bin_size,
                                                     min_pos=-np.pi,
                                                     max_pos=np.pi,
                                                     speed_thr=2,
                                                     speed=speed
                                                     )

        # find the number of indices that aligns rzone1 with rzone 1
        if rzone0[0] > rzone1[0]:
            shift = int(
                np.round((circ_rzone0[0]-circ_rzone1[0])/circ_bin_size))
        elif rzone1[0] > rzone0[0]:
            shift = - \
                int(np.round((circ_rzone1[0]-circ_rzone0[0])/circ_bin_size))

        print(shift)

        tm[0][multi_anim_sess_in[an]['trial dict']['trial_set1'], :, :] = np.roll(
            tm[0][multi_anim_sess_in[an]['trial dict']['trial_set1'], :, :],
            shift,
            axis=1
        )

        circ_rzone1_to_plot = circ.wrap(
            circ_rzone1 + circ.wrap(circ_rzone0[0]-circ_rzone1[0])
        )

        reward_zone = np.vstack((
            np.tile(np.expand_dims(circ_rzone0, 1).T, (len(
                np.where(multi_anim_sess_in[an]['trial dict']['trial_set0'])[0]), 1)),
            np.tile(np.expand_dims(circ_rzone1_to_plot, 1).T, (len(
                np.where(multi_anim_sess_in[an]['trial dict']['trial_set1'])[0]), 1))
        ))
    else:
        reward_zone = multi_anim_sess_in[an]["rzone"]  # /10

        if use_speed_thr:
            tm = TwoPUtils.spatial_analyses.trial_matrix(multi_anim_sess_in[an]['sess'].timeseries[ts_key].T,
                                                         multi_anim_sess_in[an]['sess'].vr_data['pos'].values,
                                                         multi_anim_sess_in[an]['sess'].trial_start_inds,
                                                         multi_anim_sess_in[an]['sess'].teleport_inds,
                                                         bin_size=lin_bin_size,
                                                         min_pos=min_pos,
                                                         max_pos=max_pos,
                                                         speed_thr=2,
                                                         speed=speed
                                                         )
        else:
            tm = np.copy(multi_anim_sess_in[an]["sess"].trial_matrices[ts_key])

    # Define place cell masks to plot
    if type(cell_mask) is not bool:
        pc_masks = np.zeros((tm[0].shape[2],)).astype(bool)
        pc_masks[cell_mask] = True
    else:
        pc_masks = cell_mask

    cell_sim_mat = dict()

    use_tm = tm[0][:, :, pc_masks]

    for c in range(use_tm.shape[-1]):

        mat = use_tm[:, :, c]
        mat = ut.nansmooth(mat, 2, axis=1)

        if sim_method == 'cosine_sim':
            cell_sim_mat[c] = spatial.cosine_similarity(mat, zscore=True)
        elif sim_method == 'correlation':
            cell_sim_mat[c] = spatial.corr_mat(mat)

    # ---- Plot single cell place fields and trial-by-trial similarity matrices ----

    cell_range = [0, pc_masks.sum()]

    xstride = 3
    ystride = 3
    nperrow = 8
    fig = plt.figure(figsize=[nperrow * xstride,
                              cell_range[-1] / nperrow * ystride])
    gs = gridspec.GridSpec(
        math.ceil(cell_range[-1] / nperrow) * ystride, xstride * nperrow
    )  # defined resolution for plot grid

    set0_map = use_tm[multi_anim_sess_in[an]['trial dict']['trial_set0'], :, :]
    set1_map = use_tm[multi_anim_sess_in[an]['trial dict']['trial_set1'], :, :]
    lags = xc.xcorr_lags(len(tm[-1]), len(tm[-1]), mode="same")

    xc_mat = np.zeros((use_tm.shape[2], len(lags)))*np.nan
    xc_peaks = np.zeros((use_tm.shape[2],))*np.nan

    for roi in range(0, set0_map.shape[2]):
        # trial_avg map
        this_cell_map0 = np.nanmean(set0_map[:, :, roi], axis=0)
        this_cell_map1 = np.nanmean(set1_map[:, :, roi], axis=0)

        xc_mat[roi, :] = sp.signal.correlate(this_cell_map0/np.nanmax(this_cell_map0),
                                             this_cell_map1 /
                                             np.nanmax(this_cell_map1),
                                             mode="same") / len(lags)

        xc_peaks[roi] = lags[ut.nanargmax(xc_mat[roi, :])]

    for cell in range(cell_range[0], cell_range[-1]):

        ID = np.where(pc_masks)[0][cell]
        cs = cell_sim_mat[cell]

        pf, pf_vlim = single_cell_mat(
            cell, use_tm, sigma=sigma, normalization_method="mean",
        )

        # add plots
        row_i = int(ystride * math.floor(cell / nperrow))
        col_i = int(xstride * (cell % nperrow))

        pf_ax = fig.add_subplot(gs[row_i: row_i + ystride - 1, col_i])
        if circ_shift:
            plot_single_cell(
                pf_ax,
                trial_mat=pf,
                vlim=pf_vlim,
                reward_zone=reward_zone,
                markersize=1,
                label_axes=False,
                extent=(tm[-1][0], tm[-1][-1], use_tm.shape[0], 0))  # (left, right, bottom, top))
        else:
            plot_single_cell(
                pf_ax,
                trial_mat=pf,
                vlim=pf_vlim,
                reward_zone=reward_zone,
                markersize=1,
                label_axes=False,)
            # extent = (tm[-1][0], tm[-1][-1], use_tm.shape[0], 0) #(left, right, bottom, top))

        cs_ax = fig.add_subplot(
            gs[row_i: row_i + ystride - 1, col_i + 1: col_i + 1 + xstride - 1]
        )  # specifiy which grid to plot cells
        cs_ax.imshow(
            cs,
            cmap="cividis",
            aspect="auto",
            vmin=0,
            vmax=1,
        )

        cs_ax.set_yticks([])
        cs_ax.set_xticks([])

        cs_ax.set_title(("%d, xc %d" % (ID,
                                        xc_peaks[cell]
                                        )),
                        fontsize=10
                        )

        if row_i == 0 and col_i == 0:
            pf_ax.set_ylabel("Trial #")

    fig.patch.set_facecolor("white")

    return fig, figtag


def placecell_sort_by_trial_subset(dff,
                                   pc_masks,
                                   trial_set0=None,
                                   trial_set1=None,
                                   sigma=2,
                                   sort_by_set=0,
                                   normalization='cv_max',
                                   ):
    """
    Plot sorted place cells split by trial subset,
    sorted by peak locations on subset 0.

    Automatically normalizes by the max of the cross-val trials.

    :param dff: dff array of shape trials x spatial bins x ROIs
    :param pc_masks: boolean mask of which ROIs are place cells
    :param trial_set0: boolean mask of which trials belong in trial set 0
    :param trial_set1: boolean mask of which trials belong in trial set 1
    :param sigma: smoothing gaussian s.d. (bins)
    :param normalization: 'cv_max' for cross-validated max or 'mean' for session mean
    :return: set0_map, set1_map: sorted, smoothed activity maps for each trial set
    """

    if sort_by_set == 0:
        sort_by = trial_set0
        test_set = trial_set1
    elif sort_by_set == 1:
        sort_by = trial_set1
        test_set = trial_set0
    else:
        raise NotImplementedError("Expecting sort_by_set to be 0 or 1")

    if sort_by is None:
        sort_by = np.logical(np.ones(dff.shape[0],))

    # Get cross-validated sort and map from the sort-by set
    train_sort, train_map, train_max = spatial.cross_val_sort(
        dff[sort_by][:, :, pc_masks], axis=0)

    # even trials from the training trial set
    train_map = np.nanmean(train_map, axis=0)

    test_dFF = dff[test_set][1::2, :, :]
    test_dFF = np.nanmean(test_dFF[:, :, pc_masks], axis=0)
    test_map = test_dFF[:, train_sort]
    if normalization == 'cv_max':
        test_map = test_map/train_max
        train_map = train_map/train_max
    elif normalization == 'mean':
        mean = np.nanmean(np.nanmean(dff[:, :, pc_masks][:, :, train_sort], axis=0, keepdims=True),
                          axis=1)
        train_map = train_map / mean
        test_map = test_map / mean

    train_map = ut.nansmooth(train_map.T, sigma, axis=1)
    test_map = ut.nansmooth(test_map.T, sigma, axis=1)

    if sort_by_set == 0:
        set0_map, set1_map = train_map, test_map
    elif sort_by_set == 1:
        set0_map, set1_map = test_map, train_map

    return set0_map, set1_map


def plot_population_trial_subset(set0_map,
                                 set1_map,
                                 trial_dict,
                                 ax=None,
                                 reward_zone=None,
                                 plot_reward_zone_end=False,
                                 plot_colorbar=False,
                                 vlim=[0, 0.9]):
    """
    Plot side-by-side population ratemaps for 2 trial subsets.

    :param set0_map: activity map for trial set 0
    :param set1_map: activity map for trial set 2
    :param trial_dict: dictionary of trial subsets, from behavior.define_trial_subsets
    :param ax: figure axes to plot within
    :param reward_zone: 2D array of ntrials x reward_zone [start,stop]
    :param plot_colorbar: whether to plot a colorbar
    :param vlim: color scale limits to plot (assuming max-normalization)
    :return: fig, ax for the figure
    """
    if ax is None:
        fig, ax = plt.subplots(1, 2, figsize=(15, 10))
    else:
        fig = plt.gcf()

    # Plot set0
    ax[0].imshow(set0_map, cmap='magma', aspect='auto',
                 vmin=vlim[0], vmax=vlim[1])
    if reward_zone is not None:
        if plot_reward_zone_end:
            ax[0].vlines(reward_zone[trial_dict['trial_set0'], 0]/10,
                         0,
                         set0_map.shape[0],
                         colors='white',
                         linestyle='--',
                         linewidth=0.5)
            ax[0].vlines(reward_zone[trial_dict['trial_set0'], 1]/10,
                         0,
                         set0_map.shape[0],
                         colors='white',
                         linestyle='--',
                         linewidth=0.5)
        else:
            ax[0].vlines(reward_zone[trial_dict['trial_set0'], 0]/10,
                         0,
                         set0_map.shape[0],
                         colors='white',
                         linewidth=0.5)
    ax[0].set_ylabel(f"cell #, sorted by {trial_dict['label0']}")
    ax[0].set_xlabel('position (10 cm bin)')
    ax[0].set_title(f"{trial_dict['label0']}")
    axes.Axes.set_ylim(ax[0], bottom=set0_map.shape[0])

    # Plot set1 sorted by set0
    set1_plot = ax[1].imshow(set1_map, cmap='magma',
                             aspect='auto', vmin=vlim[0], vmax=vlim[1])
    if reward_zone is not None:
        if plot_reward_zone_end:
            ax[1].vlines(reward_zone[trial_dict['trial_set1'], 0]/10,
                         0,
                         set0_map.shape[0],
                         colors='white',
                         linestyle='--',
                         linewidth=0.5)
            ax[1].vlines(reward_zone[trial_dict['trial_set1'], 1]/10,
                         0,
                         set0_map.shape[0],
                         colors='white',
                         linestyle='--',
                         linewidth=0.5)
        else:
            ax[1].vlines(reward_zone[trial_dict['trial_set1'], 0]/10,
                         0,
                         set1_map.shape[0],
                         colors='white',
                         linewidth=0.5)

    ax[1].set_ylabel(f"cell #, sorted by {trial_dict['label1']}")
    ax[1].set_xlabel('position (10 cm bin)')
    ax[1].set_title(f"{trial_dict['label1']}")
    axes.Axes.set_ylim(ax[1], bottom=set1_map.shape[0])

    if plot_colorbar:
        pt.add_colorbar(set1_plot, fig, ax[1])

    return fig, ax


def plot_population(dff_toplot,
                    ax=None,
                    reward_zone=None,
                    plot_colorbar=False,
                    vlim=[0, 0.9],
                    **kwargs):
    """
    Plot calcium dff for ROIs sorted by place field peak position.

    :param dff_toplot: calcium dff array of shape ROIs x position bins
    :param ax: figure axis
    :param reward_zone: 2D array of ntrials x reward_zone [start,stop]
    :param plot_colorbar: whether to plot a colorbar
    :return: fig, ax for the figure
    """

    # if no axis given, make a new one:
    if ax is None:
        fig, ax = plt.subplots(figsize=[5, 3])
    else:
        fig = plt.gcf()

    if 'cmap' in kwargs.keys():
        cmap = kwargs['cmap']
    else:
        cmap = 'magma'
    if 'aspect' in kwargs.keys():
        aspect = kwargs['aspect']
    else:
        aspect = 'auto'

    c_plot = ax.imshow(dff_toplot, cmap=cmap,
                       aspect=aspect, vmin=vlim[0], vmax=vlim[1])
    if reward_zone is not None:
        ax.vlines(reward_zone[:, 0]/10, 0,
                  dff_toplot.shape[0],
                  colors='white', linewidth=0.5)

    ax.set_ylabel('cell #, sorted')
    ax.set_xlabel('position (10 cm bin)')
    axes.Axes.set_ylim(ax, bottom=dff_toplot.shape[0])
    if plot_colorbar:
        fig.colorbar(c_plot, ax=ax, panchor=(0.5, 0.0))

    fig.patch.set_facecolor('white')

    return fig, ax


def plot_population_dual(dff_toplot,
                         dff2_toplot,
                         c_ax=None,
                         d_ax=None,
                         sort_by='dff',
                         reward_zone=None,
                         plot_colorbar=False,
                         vlim=[0, 0.9]):
    """
    Plot side-by-side calcium dff and another color dff (dff2) for the same ROIs
    (dual color imaging).

    :param dff_toplot: calcium dff array of shape ROIs x position bins
    :param dff2_toplot: neuromod dff array of shape ROIs x position bins
    :param c_ax: calcium figure axis
    :param d_ax: neuromod figure axis
    :param sort_by: which dataset the ROIs are already sorted by
    :param reward_zone: 2D array of ntrials x reward_zone [start,stop]
    :param plot_colorbar: whether to plot a colorbar
    :return: fig, ax for the figure
    """

    # if no axis given, make a new one:
    if c_ax is None or d_ax is None:
        fig, ax = plt.subplots(2, 4, figsize=[20, 15])
        c_ax = ax[0, 0]
        d_ax = ax[0, 1]
    else:
        fig = plt.gcf()

    c_plot = c_ax.imshow(dff_toplot, cmap='magma', aspect='auto', vmax=vlim[1])
    if reward_zone is not None:
        c_ax.vlines(reward_zone[:, 0]/10, 0,
                    dff_toplot.shape[0],
                    colors='white', linewidth=0.5)
    if sort_by == 'dff':
        c_ax.set_ylabel('cell #, ch1 sorted')
    elif sort_by == 'dff2':
        c_ax.set_ylabel('cell #, ch2 sorted')

    c_ax.set_xlabel('position (10 cm bin)')
    c_ax.set_title('ch1 dF/F')
    axes.Axes.set_ylim(c_ax, bottom=dff_toplot.shape[0])
    if plot_colorbar:
        fig.colorbar(c_plot, ax=c_ax, panchor=(0.5, 0.0))

    d_plot = d_ax.imshow(dff2_toplot, cmap='viridis',
                         aspect='auto', vmax=vlim[1])
    if reward_zone is not None:
        d_ax.vlines(reward_zone[:, 0]/10, 0,
                    dff2_toplot.shape[0], colors='white', linewidth=0.5)

    d_ax.set_xlabel('position (10 cm bin)')
    d_ax.set_title('ch2 dF/F')
    axes.Axes.set_ylim(d_ax, bottom=dff2_toplot.shape[0])
    if plot_colorbar:
        fig.colorbar(d_plot, ax=d_ax, panchor=(0.5, 0.0))

    fig.patch.set_facecolor('white')

    return fig, ax


def plot_sequences(_multiDayData,
                   celltype='rr',
                   daylist=None,
                   manual_cell_ids=None,
                   smooth=False,
                   use_peaks=True,
                   use_circ_mean=False,
                   plot=False,
                   save_figures=False,
                   fig_dir=None,
                   fig_tag='',
                   sort_by_set1=False,
                   last_10_trials=False,
                   vmax=1,
                   vbin=0.5,
                   vmin=0,
                   include_ans=None,
                   p_thr=0.05,
                   exc_end_cells=False,
                   plot_teleport=False):
    """
    Compute (and plot) cross-validated place cell sequences
    and circular-circular correlation coefficients of peak positions
    before and after a reward switch 
    """

    import phase_precession.core as ppcore
    import seaborn as sns
    import astropy

    # run fig params so we don't lose tickmarks
    pt.set_fig_params(fontsize=12)

    if sort_by_set1:
        fig_tag = fig_tag + "sortbyset1"
    if exc_end_cells:
        fig_tag = fig_tag + "_noEndCells"

    if (fig_dir is None) and save_figures:
        from reward_relative.path_dict_firebird import path_dictionary as path_dict
        fig_dir = ut.make_fig_dir(path_dict)

    # circ_bin_size = 2*np.pi/(450/10)

    if daylist is None:
        daylist = _multiDayData.keys()
    # max_anim_list
    if include_ans is None:
        include_ans = _multiDayData[daylist[0]
                                    ].circ_rel_stats_across_an['include_ans']
    seq = {}
    seq_df = pd.DataFrame(columns=[
                          'mouse', 'day', 'switch', 'cc_rho', 'cc_p', 'cc_rho_perm99', 'p_from_shuf'])
    rdist_to_rad_inc = _multiDayData[daylist[0]
                                     ].circ_rel_stats_across_an['rdist_to_rad_inc']

    nperms = 1000
    rng = np.random.default_rng()

    for d_i, d in enumerate(daylist):

        if plot:
            if len(include_ans) == 1:
                fig, ax = plt.subplots(len(include_ans)+1, 2, figsize=(
                    8, 3*len(include_ans)), sharex=True)
            else:
                fig, ax = plt.subplots(len(include_ans), 2, figsize=(
                    8, 3*len(include_ans)), sharex=True)

        seq[d] = {}
        for an_i, an in enumerate(include_ans):

            if (an in _multiDayData[d].anim_list):

                cc_rho_perm = np.zeros((nperms,))
                seq[d][an] = {}

                circ_trial_matrix = _multiDayData[d].circ_trial_matrix[an][0]
                # np.arange(-np.pi, np.pi + circ_bin_size, circ_bin_size)
                tm_bin_edges = _multiDayData[d].circ_trial_matrix[an][-2]
                # tm_bin_edges[:-1] + circ_bin_size / 2
                tm_bin_centers = _multiDayData[d].circ_trial_matrix[an][-1]
                lin_pos_bin_centers = _multiDayData[d].activity_matrix[an][-1]
                if type(_multiDayData[d].activity_matrix[an]) is tuple:
                    # if we kept the bin edges and centers
                    max_pos = _multiDayData[d].activity_matrix[an][-2][-1]
                    min_pos = _multiDayData[d].activity_matrix[an][-2][0]
                else:
                    max_pos = _multiDayData[d].pos_bin_centers[an][-1] + \
                        np.mean(
                            np.diff(_multiDayData[d].pos_bin_centers[an]))/2
                    min_pos = _multiDayData[d].pos_bin_centers[an][0] - \
                        np.mean(
                            np.diff(_multiDayData[d].pos_bin_centers[an]))/2

                # find the mean of the session per cell for normalization
                norm_per_cell = np.nanmean(np.nanmean(
                    circ_trial_matrix, axis=0, keepdims=True), axis=1)

                mat0 = _multiDayData[d].circ_map[an]['set 0']

                # in case we only want to use the last 10 trials after the switch for set 1 sequences
                if last_10_trials:
                    mat1 = _multiDayData[d].circ_map[an]['set 1'][-10:, :, :]
                else:
                    mat1 = _multiDayData[d].circ_map[an]['set 1']

                if manual_cell_ids is not None:
                    keep = manual_cell_ids
                else:
                    if celltype == 'rr':
                        keep = _multiDayData[d].reward_rel_cell_ids[an]
                    elif celltype == 'stable':
                        keep = np.where(
                            _multiDayData[d].cell_class[an]['masks']['stable'])[0]
                        keep = np.where(
                            _multiDayData[d].cell_class[an]['masks']['appear'])[0]
                    elif celltype == 'disappear':
                        keep = np.where(
                            _multiDayData[d].cell_class[an]['masks']['disappear'])[0]
                    elif celltype == 'nonreward_remap':
                        keep = np.where(
                            _multiDayData[d].cell_class[an]['masks']['nonreward_remap'])[0]
                    elif celltype == 'unstable':
                        keep = np.where((_multiDayData[d].cell_class[an]['masks']['appear'] |
                                         _multiDayData[d].cell_class[an]['masks']['disappear'] |
                                         _multiDayData[d].cell_class[an]['masks']['nonreward_remap']
                                         ))[0]
                    if celltype != 'rr':
                        # exclude cells that also qualified as RR
                        print(
                            f'how many {celltype} were also RR? {np.sum(np.isin(keep, _multiDayData[d].reward_rel_cell_ids[an]))}')
                        keep = keep[~np.isin(
                            keep, _multiDayData[d].reward_rel_cell_ids[an])]

                if exc_end_cells:
                    pos = _multiDayData[d].pos_bin_centers[an]
                    print(
                        'excluding end cells assuming first and last bin are the ends')
                    end_cells = np.logical_or(
                        np.logical_or(
                            _multiDayData[d].peaks[an]['set 0'] == pos[0], _multiDayData[d].peaks[an]['set 0'] == pos[-1]),
                        np.logical_or(_multiDayData[d].peaks[an]['set 1'] == pos[0], _multiDayData[d].peaks[an]['set 1'] == pos[-1]))
                    not_end_cells = np.where(~end_cells)[0]

                    keep = keep[np.isin(keep, not_end_cells)]

                # keep cells of this "cell type"
                norm_per_cell = norm_per_cell[:, keep]

                # specifically for rr cells
                seq[d][an]['reward_rel_dist_along_unity'] = _multiDayData[d].reward_rel_dist_along_unity[an]

                # ind in list of place cell inds (and rel peaks) matching this celltype
                ind = ut.lookup_ind_exact(keep,
                                          np.where(_multiDayData[d].overall_place_cell_masks[an])[0])
                # get rid of nans first
                ind = ind[~np.isnan(ind)].astype(int)

                # get the position of each cell in the sequence relative to reward
                seq[d][an]['dist_to_reward0'] = _multiDayData[d].rel_peaks[an]['set 0'][ind]
                seq[d][an]['dist_to_reward1'] = _multiDayData[d].rel_peaks[an]['set 1'][ind]

                mat0 = mat0[:, :, keep]
                mat1 = mat1[:, :, keep]

                # optional smoothing across position bins
                if smooth:
                    map0 = np.nanmean(ut.nansmooth(mat0, 1, axis=1),
                                      axis=0)
                    map1 = np.nanmean(ut.nansmooth(mat1, 1, axis=1),
                                      axis=0)
                else:
                    map0 = np.nanmean(mat0,
                                      axis=0)
                    map1 = np.nanmean(mat1,
                                      axis=0)

                # option to use the circular mean of the firing instead of the peak to sort
                if use_circ_mean:
                    weights0 = map0 - \
                        np.nanmin(map0, axis=0) + 0.001  # nonnegative
                    weights1 = map1 - \
                        np.nanmin(map1, axis=0) + 0.001  # nonnegative
                    circ_mean0_orig = np.asarray([astropy.stats.circstats.circmean(
                        tm_bin_centers, weights=weights0[:, c])
                        for c in range(map0.shape[1])])
                    circ_mean1_orig = np.asarray([astropy.stats.circstats.circmean(
                        tm_bin_centers, weights=weights1[:, c])
                        for c in range(map1.shape[1])])

                if map0.shape[1] < 2:  # if there is only 1 cell
                    sorted_map0 = map0
                    sorted_map1 = map1
                    sort0, sort1 = np.nan, np.nan
                    pos0, pos1 = np.nan, np.nan
                    cc_rho, cc_pval = np.nan, np.nan
                    seq[d][an]['seq0'] = np.nan
                    seq[d][an]['seq1'] = np.nan
                    seq[d][an]['pos0'] = pos0
                    seq[d][an]['pos1'] = pos1
                    seq[d][an]['mean_activity0'] = np.array(np.nan)
                    seq[d][an]['mean_activity1'] = np.array(np.nan)
                    seq[d][an]['cc rho'] = cc_rho
                    seq[d][an]['cc p'] = cc_pval
                    seq[d][an]['cc rho perm'] = np.nan
                else:
                    if smooth:
                        if "unsmoothed" in fig_tag:
                            fig_tag = fig_tag.replace(
                                "unsmoothed", "smoothed")

                        if celltype == 'appear' or sort_by_set1:
                            ref_sort, test_map1, ref_norm = spatial.cross_val_sort(ut.nansmooth(mat1, 1, axis=1),
                                                                                   axis=0)
                        else:
                            ref_sort, test_map0, ref_norm = spatial.cross_val_sort(ut.nansmooth(mat0, 1, axis=1),
                                                                                   axis=0)
                    else:
                        if celltype == 'appear' or sort_by_set1:
                            print('using set 1')
                            ref_sort, test_map1, ref_norm = spatial.cross_val_sort(mat1,
                                                                                   axis=0)
                        else:
                            ref_sort, test_map0, ref_norm = spatial.cross_val_sort(mat0,
                                                                                   axis=0)

                    if celltype == 'appear' or sort_by_set1:
                        sorted_map0 = map0[:, np.squeeze(ref_sort)]
                        sorted_map1 = np.nanmean(test_map1, axis=0)
                    else:
                        sorted_map0 = np.nanmean(test_map0, axis=0)
                        sorted_map1 = map1[:, np.squeeze(ref_sort)]

                    # normalize to the peaks from the training trials (odd, before)
                    # sorted_map0 = sorted_map0 / ref_norm
                    # sorted_map1 = sorted_map1 / ref_norm

                    # find the peak bin indices of the sorted data, before and after reward switch
                    pos0 = ut.nanargmax(sorted_map0, axis=0)
                    pos1 = ut.nanargmax(sorted_map1, axis=0)

                    # find the mean activity across cells
                    mean_activity0 = np.nanmean(sorted_map0, axis=-1)
                    mean_activity1 = np.nanmean(sorted_map1, axis=-1)

                    cc_rho, cc_pval, _ = ppcore.corr_cc(
                        tm_bin_centers[pos0], tm_bin_centers[pos1])

                    # Get cc corr from permuted cell IDs
                    for n in range(nperms):
                        perm_ids = rng.permutation(np.arange(map0.shape[1]))
                        sorted_map1_perm = map1[:,
                                                np.squeeze(perm_ids[ref_sort])]
                        pos1_perm = ut.nanargmax(sorted_map1_perm, axis=0)

                        if use_circ_mean:
                            cc_rho_perm[n], _, _ = ppcore.corr_cc(
                                circ_mean0, circ_mean1_orig[perm_ids[ref_sort]])
                        else:
                            cc_rho_perm[n], _, _ = ppcore.corr_cc(
                                tm_bin_centers[pos0], tm_bin_centers[pos1_perm])

                    # peak positions in sequence
                    seq[d][an]['seq0'] = tm_bin_centers[pos0]
                    seq[d][an]['seq1'] = tm_bin_centers[pos1]
                    seq[d][an]['pos0'] = pos0
                    seq[d][an]['pos1'] = pos1
                    seq[d][an]['cell_order'] = ref_sort
                    seq[d][an]['mean_activity0'] = mean_activity0
                    seq[d][an]['mean_activity1'] = mean_activity1
                    seq[d][an]['cc rho'] = cc_rho
                    seq[d][an]['cc p'] = cc_pval
                    seq[d][an]['cc rho perm'] = cc_rho_perm
                    # two-sided permutation test
                    seq[d][an]['cc p perm'] = (np.sum(
                        np.abs(seq[d][an]['cc rho perm']) >= np.abs(seq[d][an]['cc rho'])) + 1) / (nperms + 1)

                    # normalize to the maximum of the trial-averaged spatially-binned activity across the whole session,
                    # for each cell (for visualization only)
                    # max_before = np.nanmax(sorted_map0, axis=0, keepdims=True)
                    # stack_maps = np.concatenate([sorted_map0[:,:,np.newaxis], sorted_map1[:,:,np.newaxis]], axis=2)
                    # # max_per_cell = np.nanmax(np.nanmax(stack_maps, axis=2), axis=0, keepdims=True)
                    # mean_per_cell = np.nanmean(np.nanmean(stack_maps, axis=2), axis=0, keepdims=True)
                    # sorted_map0 = sorted_map0 / mean_per_cell
                    # sorted_map1 = sorted_map1 / mean_per_cell

                    # normalize each cell to its own mean
                    sorted_map0 = sorted_map0 / \
                        norm_per_cell[:, ref_sort]  # ref_norm #
                    sorted_map1 = sorted_map1 / \
                        norm_per_cell[:, ref_sort]  # ref_norm #

                    if plot:

                        ax[an_i, 0].imshow(sorted_map0.T, extent=(-np.pi, np.pi, sorted_map0.shape[-1], 0),
                                           cmap='magma', aspect='auto', vmin=vmin, vmax=vmax)

                        ax[an_i, 0].vlines(spatial.pos_cm_to_rad(_multiDayData[d].rzone_pos[an]['set 0'], max_pos, min_pos),
                                           sorted_map0.shape[1], 0,
                                           color='w', linestyle=':')
                        h = ax[an_i, 1].imshow(sorted_map1.T, extent=(-np.pi, np.pi, sorted_map0.shape[-1], 0),
                                               cmap='magma', aspect='auto', vmin=vmin, vmax=vmax)

                        ax[an_i, 1].vlines(spatial.pos_cm_to_rad(_multiDayData[d].rzone_pos[an]['set 1'], max_pos, min_pos),
                                           sorted_map1.shape[1], 0,
                                           color='w', linestyle=':')

                        if plot_teleport:
                            # look up end of track position in the original pos bin centers
                            # tele_ind = ut.lookup_ind(450, lin_pos_bin_centers)
                            tele_circ = spatial.pos_cm_to_rad(
                                450, max_pos, min_pos)
                            # also look up start of track
                            # start_ind = ut.lookup_ind(0, lin_pos_bin_centers)
                            start_circ = spatial.pos_cm_to_rad(
                                0, max_pos, min_pos)
                            ax[an_i, 0].vlines(tele_circ,
                                               sorted_map0.shape[1], 0,
                                               color='grey', linestyle='--')
                            ax[an_i, 1].vlines(tele_circ,
                                               sorted_map1.shape[1], 0,
                                               color='grey', linestyle='--')
                            ax[an_i, 0].vlines(start_circ,
                                               sorted_map0.shape[1], 0,
                                               color='grey', linestyle='--')
                            ax[an_i, 1].vlines(start_circ,
                                               sorted_map1.shape[1], 0,
                                               color='grey', linestyle='--')

                        ax[an_i, 0].set_title("mouse%s cc r=%.2f p=%.3e, p_perm=%.3e, n=%d" % (
                            ut.get_mouse_number(an), cc_rho, cc_pval,
                            seq[d][an]['cc p perm'], sorted_map0.shape[1])
                        )
                        ax[an_i, 0].set_xticks([-3, -2, -1, 0, 1, 2, 3])
                        ax[an_i, 1].set_xticks([-3, -2, -1, 0, 1, 2, 3])
                        ax[an_i, 0].set_ylabel('cells, before-sorted')
                        ax[an_i, 0].set_xlabel('track pos (rad)')
                        fig.suptitle("Day %d" % d)

                        pt.colorbar(h, ticks=np.arange(vmin, vmax+vbin, vbin))
                        # pt.add_colorbar(h, fig, ax[an_i, 1])

        if save_figures:
            if plot:
                pt.savefig(fig, fig_dir, "%s_expday%d_CellSequence-%s_PeakCrossVal_%s_%s_%s_normtoSessMean-xcorrthr-twosided" % (
                    ut.make_anim_tag(include_ans), d, celltype,
                    _multiDayData[d].ts_key, fig_tag, _multiDayData[d].place_cell_logical),
                    extension=".pdf"
                )

    if plot:
        fig_q, ax_q = plt.subplots(figsize=(4.5, 4))

    # Plot circular correlation coefficients
    palette = 'tab10'
    seaborn_palette = sns.color_palette(
        palette, len(include_ans))  # , as_cmap=True)
    rgb_tuples = [sns.color_palette(seaborn_palette)[i]
                  for i in range(len(seaborn_palette))]
    cmap = np.asarray(rgb_tuples)

    for d_i, d in enumerate(seq.keys()):

        cc_rhos = np.zeros((len(include_ans),))*np.nan
        cc_ps = np.zeros((len(include_ans),))*np.nan
        cc_rhos_shuf = np.zeros((len(include_ans),))*np.nan
        p_from_shuf = np.zeros((len(include_ans),))*np.nan
        n_cells = np.zeros((len(include_ans),))*np.nan

        jitter = np.linspace(-0.1, 0.1, len(include_ans))

        for an_i, an in enumerate(seq[d].keys()):
            if np.any(np.isnan(seq[d][an]['pos0'])):
                seq[d][an]['pos0'] = [0]
            n_cells[include_ans.index(an)] = len(seq[d][an]['pos0'])
            if n_cells[include_ans.index(an)] >= 5:
                cc_rhos[include_ans.index(an)] = seq[d][an]['cc rho']
                cc_ps[include_ans.index(an)] = seq[d][an]['cc p']
                cc_rhos_shuf[include_ans.index(an)] = np.nanpercentile(
                    seq[d][an]['cc rho perm'], (1-p_thr)*100)
                p_from_shuf[include_ans.index(an)] = seq[d][an]['cc p perm']  # (
                # seq[d][an]['cc rho perm'] > seq[d][an]['cc rho']).sum() / nperms

        _include_ans = np.array(include_ans)
        p_from_shuf = np.asarray(p_from_shuf)

        df_this_day = pd.DataFrame({'mouse': _include_ans,
                                    'day': np.repeat(d, len(_include_ans)),
                                    'switch': np.repeat(d_i, len(_include_ans)),
                                    'cc_rho': cc_rhos,
                                    'cc_p': cc_ps,
                                    'cc_rho_perm95': cc_rhos_shuf,
                                    'p_from_shuf': p_from_shuf}
                                   )

        seq_df = seq_df.append(df_this_day, ignore_index=True)

        if plot:
            ax_q.scatter(d_i+jitter[p_from_shuf < p_thr]+0.2, cc_rhos[p_from_shuf <
                                                                      p_thr], marker='o', color=cmap[p_from_shuf < p_thr], alpha=0.6)
            ax_q.scatter(d_i+jitter[p_from_shuf >= p_thr]+0.2, cc_rhos[p_from_shuf
                                                                       >= p_thr], marker='o', color=cmap[p_from_shuf >= p_thr],
                         facecolor='none', alpha=0.6)
            ax_q.scatter(d_i+jitter-0.2, cc_rhos_shuf, marker='x',
                         c=cmap, alpha=0.6)

            ax_q.set_ylim([-0.5, 1.1])
            ax_q.set_ylabel('rho')
            ax_q.set_xlabel('switch')

    # dummy plotting to generate legend because I couldn't figure it out from the scatter
    if plot:
        for an_i in range(len(include_ans)):
            ax_q.plot(0, np.nan, 'o',
                      color=cmap[an_i], label=include_ans[an_i])
        ax_q.legend(loc="upper right",
                    bbox_to_anchor=(1.3, 1))

        ax_q.set_xticks(np.arange(len(seq.keys())))

        if save_figures:
            pt.savefig(fig_q, fig_dir, "%s_expday%s_CorrCC-%s_%s_%s_%s_%s_two-sided%s_xcorrthr" % (
                ut.make_anim_tag(include_ans), ut.make_day_tag(
                    daylist), celltype, _multiDayData[d].ts_key,
                fig_tag, _multiDayData[d].place_cell_logical, palette, str(p_thr))
            )

    if plot:
        return seq, fig, fig_q
    else:
        return seq, [], []
